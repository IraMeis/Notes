# Распараллеливание циклических фрагментов программ (пространство итераций, ускорение, метод пирамид)

Обозревая инструментальный набор вычислительной математики непросто обнаружить численный метод, в котором большая часть арифметических операций не выполнялась бы циклически. У итерационных методов решения нелинейных уравнений, систем линейных и нелинейных уравнений, указанная особенность даже упомянута в названии. В практике программирования она реализуется посредством циклических конструкций.

## Пространство итераций
Остановимся на рассмотрении вложенной циклической конструкции, представленной в Программе 2.2.
![[Pasted image 20220612181002.png]]
Тело циклической конструкции $T(i_{1}, i_{2}, \dots, i_{k})$ Программы 2.2 содержит операторы, характеризующие численный метод, в которых используются значения параметров циклов $i_{1}, i_{2}, \dots, i_{k}$, возможно не все. 

Здесь, как и в предыдущем параграфе, необходимо перейти от программы к ее математической модели. Затем, в рамках этой модели, поставить цель, достижение которой связать с построением параллельного алгоритма. Формулируя его сначала на языке модели, затем вне его, возвращаясь к привычному перечислению инструкций. 

Поставим каждой итерации вложенной циклической конструкции Программы 2.2 во взаимно однозначное соответствие вектор $(i_{1}, i_{2}, \dots, i_{K})$, где $1\leq i_{k} \leq n_{k}, \ 1\leq k \leq K$; различая прямое и наклонное написание одних и тех же букв. Относя прямое к математической модели программы, наклонное – к коду и понимая их связь. Совокупность всех таких векторов для обсуждаемой циклической конструкции составит относящееся к ней пространство итераций $I=\{ (i_{1}, i_{2}, \dots, i_{K}): \ 1\leq i_{k} \leq n_{k}, \ 1\leq k \leq K \}$. 

На построенном пространстве зададим два бинарных отношения, предварительно представив всю циклическую конструкцию в «развернутом» ациклическом виде: $T(1, \dots, 1,1); \ T(1, \dots, 1,2); \dots T(1, \dots, 1, n_{k}); T(1, \dots, 2, 1); \dots T(n_{1}, \dots, n_{K-1}, n_{K})$. Из параграфа 2.1 для нее уже известны бинарные отношения непосредственного следования и зависимости. Транзитивным замыканием отношения непосредственного следования несложно ввести бинарное отношение следования на множестве вершин стандартного графа «развернутой» конструкции. 

Помним о взаимно однозначном соотношении фрагмента кода, связанного с набором операторов $T=T(i_{1}, i_{2}, \dots, i_{k})$ в обсуждаемом ациклическом построений, и соответствующего ему вектора $i=(i_{1}, i_{2}, \dots, i_{K})$ пространства итераций. Определяя бинарное отношение следования, будем говорить, что вектор $i'$ следует в пространстве итераций I за вектором $i$, если в стандартном графе для «развернутой» конструкции любая вершина, относящаяся к фрагменту $T'$, следует за любой вершиной, связанной с $T$. 

Аналогично, определяя бинарное отношение зависимости, будем говорить, что вектор $i'$ зависит в пространстве итераций $I$ от вектора $i$, если в графе зависимостей для «развернутой» конструкции существует вершина, относящаяся к фрагменту $T'$, которая зависит от любой вершины, связанной с $T$. 

Положим своей целью отыскание покрытия $\{ I_{q} \}_{q=1,Q}$ пространства итераций $I$ такого, что любое подмножество $I_{q}$, его составляющее, содержит только независимые друг от друга вектора. Все итерации циклической конструкции, связанные с такими векторами из $I_{q}$, могут исполняться независимо – параллельно. 

Логично одной задаче искомого параллельного алгоритма, заданного обсуждаемым покрытием, предписать исполнение инструкций фрагмента $T$, связанного с вектором $i$, входящим в подмножество $I_{q}$. Тогда общее количество задач алгоритма можно принять равным мощности некоторого подмножества $Iq \ (1\leq q \leq Q)$ из найденного покрытия, содержащего наибольшее количество векторов.

Дальнейшая конкретизации алгоритма (размещение по задачам инструкций из фрагментов, связанных с векторами из разных подмножеств одного покрытия, и установка коммуникаций) зависит от используемого метода построения и подлежит объяснению далее, вместе с изложением метода. В методе же оговаривается и правило нахождения покрытия. 


## Ускорение
Ускорение вычислений по параллельному алгоритму оценим безразмерной величиной $S=\frac{\prod_{k=1}^K n_{k}}{Q}$. Действительно, при условии одинаковой длительности исполнения всех итераций и без учета коммуникационных издержек, время выполнения параллельной программы будет в Q раз меньше по сравнению со временем последовательной. Ведь все итерации, связанные с одним подмножеством $I_{q}$ исполнятся одновременно, как одна по длительности. Тогда общее время вычислений по параллельной программе окажется пропорциональным количеству подмножеств в покрытии – Q, независимо от мощности каждого подмножества; а по последовательной, пропорционально общему количеству итераций – $\prod_{k=1}^K n_{k}$. 

В общем случае может быть найдено несколько покрытий пространства итераций, удовлетворяющих требованию независимости векторов одного подмножества $I_{q}$, Лучшим принято считать характеризующееся максимальным ускорением параллельного алгоритма, с таким покрытием связанного. При этом следует помнить об ограниченной адекватности ранее представленной оценки ускорения и принимать экспериментальную практику как единственный окончательный критерий истины: «Практика выше (теоретического) познания, ибо она имеет не только достоинство всеобщности, но и непосредственной действительности». 

Предваряя изложение конкретных методов автоматического распараллеливания циклических фрагментов последовательных программ укажем на общие для них ограничения: недопустимость изменения параметров цикла в его теле и запрет на существование оператора условного перехода, ведущего за тело цикла.
## Метод пирамид
![[Pasted image 20220612182906.png]]
![[Pasted image 20220612182912.png]]
![[Pasted image 20220612182916.png]]
![[Pasted image 20220612182921.png]]
![[Pasted image 20220612182926.png]]
![[Pasted image 20220612182930.png]]
![[Pasted image 20220612182937.png]]
![[Pasted image 20220612182942.png]]