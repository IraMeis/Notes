# Автоматическое распараллеливание ациклических фрагментов последовательных программ (формализм определения функции «c»)

Отдельного внимания заслуживает обсуждение формализма определения значений функции c(A), задающей синхронизацию вычислений между задачами и коммуникации параллельного алгоритма. Обсуждаемая функция может:
- принимать значение 1 («истина»), тогда операторы, относящиеся к следующей за ней вершине A, подлежат исполнению;
- принимать значение 0 («ложь»), тогда операторы, относящиеся к следующей за ней вершине A, не подлежат исполнению, а вычислительный процесс, связанный с исполнением инструкций данной задачи, продолжается определением значения следующей за A функции $c(\dots)$;
- – не принимать определенного значения, тогда вычислительный процесс, связанный с исполнением инструкций данной задачи, приостанавливается до определения значения $c(A)$.

То есть $c(A)$ не функция в строгом математическом смысле, в рамках которого не рассматривается развитие во времени вычислительного процесса по определению ее значения. В параллельном алгоритме $c(A$), как правило, соответствует инструкциям приема данных, необходимых для выполнения операторов вершины A и формируемых в других задачах, содержащих вершины, от которых A зависит. Следовательно, в этих других задачах необходимо организовать отправку упомянутых данных.

Обращаясь непосредственно к формализму определения $c(A)$ положим, что из входной вершины стандартного графа в вершину A ведет S различных путей. Свяжем с каждым из них $(1\leq s \leq S)$ функцию $c_{s}$:
- принимающую значение 1 (“истина”), если в ходе вычислительного процесса (уже параллельного) исполнились все операторы, относящиеся к вершинам выбранного пути, от которых A зависит, таким образом, чтобы эти зависимости оказались удовлетворенными;
- принимающую значение 0 (“ложь”), если в ходе вычислительного процесса (уже параллельного) хотя бы один оператор, относящийся к любой вершине выбранного пути, от которой A зависит, заведомо не исполнится удовлетворяющим эту зависимость образом;
- пока не принимающую определенного значения, если ход вычислительного процесса не определен на столько, чтобы знать, исполнились ли обсуждаемые операторы удовлетворительным образом или не исполнились.

Что здесь понимается под удовлетворением зависимости? Для оператора присваивания, формирующего значение необходимой переменной, имеется в виду его исполнение. Говоря об операторе условного перехода, имеется в виду не только исполнение этого оператора, но и такое значение условия, при котором вычислительный процесс пойдет далее по пути, содержащем A.

Тогда $c(A)=c_{1} \lor c_{2} \lor \dots \lor c_{s}$. То есть, если течение вычислительного процесса тем или иным путем (а их всего S) дошло до исполнения действий, связанных с вершиной A, то указанные действия надлежит исполнить. Если же ни один из возможных путей в ходе вычислительного процесса не реализовался и уже точно не реализуется, то исполнять действия, связанные с A не следует.

Отметим, что обсуждаемый параллельный вычислительный процесс и последовательный процесс, описываемый стандартным графом, суть разные процессы. Что, однако, не мешает отмечать ход параллельного процесса на стандартном графе маркированием части его вершин, как пройденных, и таким образом иметь возможность говорить о реализации того или иного пути на этом графе.

Предваряя формализацию определения значений $c_{s}$ выпишем все вершины на пути $s$, от которых A зависит, в порядке из следования: $A^1, A^2,A^3,\dots,A^I$. Тогда $c_{s}=c^1 \land c^2 \land \dots c^I$. В свою очередь, при $1\leq i\leq I$:
- $c^i = c(A^i)$, если $A^i$ - преобразователь;
- $c^i = c(A^i=1)$, если $A^i$ - распознаватель и для реализации пути $s$ необходима истинность значения, связанного с ним условия (при таком значении $c_{i}=1$, иначе $0$);
- $c^i=c(A^i=0)$, если $A^i$ - распознаватель и для реализации пути $s$ необходима ложность значения, связанного с ним условия (при таком значении $c_{i} =1$, иначе $0$).

В итоге, искомое значение $c(A)$ формируется как дизъюнкция конъюнкций и зачастую результирующее выражение выглядит достаточно громоздко. Однако, может быть значительно упрощено из ряда практических соображений. Например, нет смысла проверять значение $c(A^{i})$, если вершина $A^{i}$ отнесена к той же задаче параллельного алгоритма и ее операторы действовали над общей с операторами A областью памяти. Или, если вычисление $c(A^{i})$ предваряло исполнение операторов, относящихся к $A^{j}$ (пусть даже в другой задаче), а сейчас $c(A^{i})$ подлежит проверке наряду с $c(A^{j})$; тогда довольно ограничиться определением значения только последней функции.

##### Пример
Поясним изложенное примером, продолжая работу с Программой 2.1, графами на рис. 2.1 и ЯПФ из табл. 2.2. Положим число задач искомого параллельного алгоритма равным двум и распределим вершины из ярусов ЯПФ между ними, как это показано в табл. 2.3.
![[Pasted image 20220612174640.png]]
В каждой задаче инструкции, связанные с конкретными вершинами, будут исполняться последовательно, в направлении сверху вниз по соответствующему столбцу табл. 2.3. Так, первая задача последовательно исполнит операторы, относящиеся к $A; c(C); C; c(D); D; c(E); E; c(G); G; c(H); H$. Вторая – $c(B); B; c(F); F$.

Теперь необходимо конкретизировать выражение для каждой функции $c(\dots)$, по возможности упростив его. 

Вершине A, как не зависящей ни от какой другой вершины, не предшествует функция $c(\dots)$. Оператор, к ней относящийся, исполнится без предварительных условий. 

Рассматривая c(B) примем c(B)=c(A): на пути стандартного графа из A (входная вершина) в B расположена только вершина A и B от нее зависит. Практически эта зависимость выражается в необходимости организовать прием значений переменных *a*, *b* и *c* во второй задаче (B помещена в нее) перед исполнением оператора, относящегося к вершине B, в котором эти переменные используются. Соответственно, в первой задаче за оператором, относящимся к A, полагается организовать отсылку указанных значений. 

Рассматривая $c(C)$ примем $c(C)=c(A)=1$: на пути стандартного графа из A в C расположены вершины A и B, при чем C зависит только от A. Более того, С расположена в той же задаче параллельного алгоритма (первой), что и A, следуя за ней. Значит оператор, относящийся к C, исполнится только после оператора, относящегося к A - синхронизации не требуется. К тому же оба оператора исполняются над одной областью памяти - коммуникации не требуется. В итоге, если вычислительный процесс дошел до C, то оператор, с этой вершиной связанный, может быть исполнен без всяких приготовлений. 

Рассматривая $c(D)$ примем $c(D)=c(A) \land c(C=1)=c(C=1)$: на единственном пути стандартного графа из A в D расположены вершины A, B и C, из них D зависит только от A и C. Все три далее обсуждаемые вершины (A, C и D) помещены в одну задачу, при чем C сама зависит от A и эта зависимость, как было показано выше, удовлетворяется автоматически – значит $c(A)$ можно исключить из конъюнкции. Этого нельзя сделать с $c(C=1)$, ведь в зависимости от значения условия оператора условного перехода, с C связанного, оператор, относящийся к D, может либо исполниться либо нет. На практике указанное условие реализуется помещением оператора, относящегося к вершине D, в подходящую ветку условного перехода. 

Рассматривая c(E) примем $c(E)=c(A) \land c(B)\land c(C=0)=c(B)\land c(C=0)$: на единственном пути стандартного графа из A в E расположены вершины A, B и C - E зависит от всех. Зависимостью от A, предшествующей E в той же задаче, можно пренебречь по приведенным ранее соображениям. Зависимость от B на практике реализуется отправкой из второй задачи, содержащей B, и приемом в первой, содержащей E, значения переменной d. Обращая внимание на второй сомножитель в конъюнкции, поместим оператор, относящийся к вершине E, в ветку условного перехода, отличную от той, куда ранее отнесли оператор, связанный с D. 

Определение значения c(F) аналогично предыдущему случаю с той лишь разницей, что вершина F отнесена к другой задаче. Так, $c(F)=c(A)\land c(B)\land c(C=0)=c(C=0)$. Зависимостью от A можно пренебречь в силу ее учета при формировании значения $c(B)$ во второй задаче ранее. В силу того, что вершина B предшествует F в одной задаче, зависимость от B также игнорируем. Остается учесть зависимость от С, что на практике можно сделать разными способами. Передать результат сравнения $b^2 <4ac$ из первой задачи, где оно производится при исполнении оператора условного перехода, относящегося к вершине C. Либо продублировать сравнение во второй и обойтись без дополнительной коммуникации. Ведь значения переменных *a*, *b* и *c* второй задачей получены ранее при определении $c(B)$. Далее выберем второй вариант. 

Рассматривая $c(G)$ примем $c(G)=c(A)\land c(B)˄c(C=0)\land c(E)˄c(F)=c(C=0)\land c(F)$. Зависимости от A и E здесь не существенны в силу расположения этих вершин в первой задаче перед G. Зависимость от B учтена ранее, при формировании $c(E)$. Остается поместить оператор, относящийся к G, в нужную ветку условного перехода и принять значение переменной $x_{2}$ от второй задачи, где его формирует оператор, связанный с вершиной F.
![[Pasted image 20220612174724.png]]

Особенностью рассмотрения $c(H)$ является наличие двух путей из входной вершины в H: $(c(H)=c(A)\land c(B)\land c(C=1)\land c(D)) \lor (c(A)\land c(B)\land c(C=0)\land c(E)\land c(F)\land c(G))=c(D)\lor c(G)=1$. Первый путь завершается вершиной D, второй – G. Разумно проверить исполнение инструкций, связанных только с этими вершинами, для выяснения – пройдены ли соответствующие пути или нет. К тому же, обе указанные вершины помещены в ту же задачу, где оказалась вершина H и предшествуют ей. Следовательно, производство упомянутых проверок представляется излишним. Если вычислительный процесс дошел, не важно каким путем, до оператора, связанного с G, то может не останавливаться. 

Построенный параллельный алгоритм в нотации Голуба выглядит следующим образом. 

Обратим внимание на отправку значения дискриминанта второй задачей – она производится после условного перехода. Отправка дискриминанта сразу, по его вычислению, не имеет смысла. Если $b^2 <4ac$, то в первой задаче инструкция по приему такого дискриминанта не предусмотрена. 

Автор предостерегает читателя от реализации приведенного примера, характеризующегося исключительно методической ценностью, на практике. Выигрыш от одновременного исполнения части инструкций будет нивелирован коммуникационными издержками. В действительности, к одной вершине стандартного графа и графа зависимостей необходимо относить блоки кода со значительно большим количеством операторов